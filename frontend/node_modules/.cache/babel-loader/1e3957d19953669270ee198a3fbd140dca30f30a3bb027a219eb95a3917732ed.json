{"ast":null,"code":"/* eslint-disable jsdoc/require-returns */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable valid-jsdoc */\n/**\n * Defines the behavior of a pyramid series\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { removeElement } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement } from '../../common/utils/helper';\nimport { TriangularBase } from './triangular-base';\n/**\n * PyramidSeries module used to render `Pyramid` Series.\n */\nvar PyramidSeries = /** @class */function (_super) {\n  __extends(PyramidSeries, _super);\n  function PyramidSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Defines the path of a pyramid segment\n   */\n  PyramidSeries.prototype.getSegmentData = function (point, series, chart) {\n    var area = series.triangleSize;\n    //top of th series\n    var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;\n    //consider, if the point is exploded\n    var offset = 0;\n    var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n    var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;\n    //top and bottom\n    var top = point.yRatio;\n    var bottom = point.yRatio + point.heightRatio;\n    //width of the top and bottom edge\n    var topRadius = 0.5 * (1 - point.yRatio);\n    var bottomRadius = 0.5 * (1 - bottom);\n    top += seriesTop / area.height;\n    bottom += seriesTop / area.height;\n    var line1 = {\n      x: emptySpaceAtLeft + offset + topRadius * area.width,\n      y: top * area.height\n    };\n    var line2 = {\n      x: emptySpaceAtLeft + offset + (1 - topRadius) * area.width,\n      y: top * area.height\n    };\n    var line3 = {\n      x: emptySpaceAtLeft + offset + (1 - bottomRadius) * area.width,\n      y: bottom * area.height\n    };\n    var line4 = {\n      x: emptySpaceAtLeft + offset + bottomRadius * area.width,\n      y: bottom * area.height\n    };\n    var polygon = [line1, line2, line3, line4];\n    this.setLabelLocation(series, point, polygon);\n    var direction = this.findPath(polygon);\n    return direction;\n  };\n  /**\n   * Initializes the size of the pyramid segments\n   *\n   * @private\n   */\n  PyramidSeries.prototype.initializeSizeRatio = function (points, series) {\n    if (series.pyramidMode === 'Linear') {\n      _super.prototype.initializeSizeRatio.call(this, points, series, true);\n    } else {\n      this.calculateSurfaceSegments(series);\n    }\n  };\n  /**\n   * Defines the size of the pyramid segments, the surface of that will reflect the values\n   */\n  PyramidSeries.prototype.calculateSurfaceSegments = function (series) {\n    var count = series.points.length;\n    var sumOfValues = series.sumOfPoints;\n    var y = [];\n    var height = [];\n    var gapRatio = Math.min(0, Math.max(series.gapRatio, 1));\n    var gapHeight = gapRatio / (count - 1);\n    var preSum = this.getSurfaceHeight(0, sumOfValues);\n    var currY = 0;\n    for (var i = 0; i < count; i++) {\n      if (series.points[i].visible) {\n        y[i] = currY;\n        height[i] = this.getSurfaceHeight(currY, Math.abs(series.points[i].y));\n        currY += height[i] + gapHeight * preSum;\n      }\n    }\n    var coef = 1 / (currY - gapHeight * preSum);\n    for (var i = 0; i < count; i++) {\n      if (series.points[i].visible) {\n        series.points[i].yRatio = coef * y[i];\n        series.points[i].heightRatio = coef * height[i];\n      }\n    }\n  };\n  /**\n   * Finds the height of pyramid segment\n   */\n  PyramidSeries.prototype.getSurfaceHeight = function (y, surface) {\n    var result = this.solveQuadraticEquation(1, 2 * y, -surface);\n    return result;\n  };\n  /**\n   * Solves quadratic equation\n   */\n  PyramidSeries.prototype.solveQuadraticEquation = function (a, b, c) {\n    var root1;\n    var root2;\n    var d = b * b - 4 * a * c;\n    if (d >= 0) {\n      var sd = Math.sqrt(d);\n      root1 = (-b - sd) / (2 * a);\n      root2 = (-b + sd) / (2 * a);\n      return Math.max(root1, root2);\n    }\n    return 0;\n  };\n  /**\n   * Renders a pyramid segment\n   */\n  PyramidSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw) {\n    if (!point.visible) {\n      removeElement(options.id);\n      return null;\n    }\n    options.d = this.getSegmentData(point, series, chart);\n    point.midAngle = 0;\n    var element = chart.renderer.drawPath(options);\n    element.setAttribute(\"tabindex\", point.index === 0 ? \"0\" : \"\");\n    element.setAttribute('aria-label', point.x + \": \" + point.y + '%. ' + series.name);\n    appendChildElement(false, seriesGroup, element, redraw);\n    if (point.isExplode) {\n      chart.accBaseModule.explodePoints(point.index, chart, true);\n    }\n  };\n  /**\n   * To get the module name of the Pyramid series.\n   */\n  PyramidSeries.prototype.getModuleName = function () {\n    return 'PyramidSeries';\n  };\n  /**\n   * To destroy the pyramid series\n   *\n   * @returns {void}\n   * @private\n   */\n  PyramidSeries.prototype.destroy = function () {\n    /**\n     * Destroys the pyramid series\n     */\n  };\n  return PyramidSeries;\n}(TriangularBase);\nexport { PyramidSeries };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","removeElement","appendChildElement","TriangularBase","PyramidSeries","_super","apply","arguments","getSegmentData","point","series","chart","area","triangleSize","seriesTop","initialClipRect","y","height","offset","extraSpace","width","emptySpaceAtLeft","x","top","yRatio","bottom","heightRatio","topRadius","bottomRadius","line1","line2","line3","line4","polygon","setLabelLocation","direction","findPath","initializeSizeRatio","points","pyramidMode","call","calculateSurfaceSegments","count","length","sumOfValues","sumOfPoints","gapRatio","Math","min","max","gapHeight","preSum","getSurfaceHeight","currY","i","visible","abs","coef","surface","result","solveQuadraticEquation","a","c","root1","root2","sd","sqrt","renderPoint","options","seriesGroup","redraw","id","midAngle","element","renderer","drawPath","setAttribute","index","name","isExplode","accBaseModule","explodePoints","getModuleName","destroy"],"sources":["/Users/thonghoangdanh/FullStack/birdnest/node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pyramid-series.js"],"sourcesContent":["/* eslint-disable jsdoc/require-returns */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable valid-jsdoc */\n/**\n * Defines the behavior of a pyramid series\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { removeElement } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement } from '../../common/utils/helper';\nimport { TriangularBase } from './triangular-base';\n/**\n * PyramidSeries module used to render `Pyramid` Series.\n */\nvar PyramidSeries = /** @class */ (function (_super) {\n    __extends(PyramidSeries, _super);\n    function PyramidSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Defines the path of a pyramid segment\n     */\n    PyramidSeries.prototype.getSegmentData = function (point, series, chart) {\n        var area = series.triangleSize;\n        //top of th series\n        var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;\n        //consider, if the point is exploded\n        var offset = 0;\n        var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n        var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;\n        //top and bottom\n        var top = point.yRatio;\n        var bottom = point.yRatio + point.heightRatio;\n        //width of the top and bottom edge\n        var topRadius = 0.5 * (1 - point.yRatio);\n        var bottomRadius = 0.5 * (1 - bottom);\n        top += seriesTop / area.height;\n        bottom += seriesTop / area.height;\n        var line1 = {\n            x: emptySpaceAtLeft + offset + topRadius * area.width,\n            y: top * area.height\n        };\n        var line2 = {\n            x: emptySpaceAtLeft + offset + (1 - topRadius) * area.width,\n            y: top * area.height\n        };\n        var line3 = {\n            x: emptySpaceAtLeft + offset + (1 - bottomRadius) * area.width,\n            y: bottom * area.height\n        };\n        var line4 = {\n            x: emptySpaceAtLeft + offset + bottomRadius * area.width,\n            y: bottom * area.height\n        };\n        var polygon = [line1, line2, line3, line4];\n        this.setLabelLocation(series, point, polygon);\n        var direction = this.findPath(polygon);\n        return direction;\n    };\n    /**\n     * Initializes the size of the pyramid segments\n     *\n     * @private\n     */\n    PyramidSeries.prototype.initializeSizeRatio = function (points, series) {\n        if (series.pyramidMode === 'Linear') {\n            _super.prototype.initializeSizeRatio.call(this, points, series, true);\n        }\n        else {\n            this.calculateSurfaceSegments(series);\n        }\n    };\n    /**\n     * Defines the size of the pyramid segments, the surface of that will reflect the values\n     */\n    PyramidSeries.prototype.calculateSurfaceSegments = function (series) {\n        var count = series.points.length;\n        var sumOfValues = series.sumOfPoints;\n        var y = [];\n        var height = [];\n        var gapRatio = Math.min(0, Math.max(series.gapRatio, 1));\n        var gapHeight = gapRatio / (count - 1);\n        var preSum = this.getSurfaceHeight(0, sumOfValues);\n        var currY = 0;\n        for (var i = 0; i < count; i++) {\n            if (series.points[i].visible) {\n                y[i] = currY;\n                height[i] = this.getSurfaceHeight(currY, Math.abs(series.points[i].y));\n                currY += height[i] + gapHeight * preSum;\n            }\n        }\n        var coef = 1 / (currY - gapHeight * preSum);\n        for (var i = 0; i < count; i++) {\n            if (series.points[i].visible) {\n                series.points[i].yRatio = coef * y[i];\n                series.points[i].heightRatio = coef * height[i];\n            }\n        }\n    };\n    /**\n     * Finds the height of pyramid segment\n     */\n    PyramidSeries.prototype.getSurfaceHeight = function (y, surface) {\n        var result = this.solveQuadraticEquation(1, 2 * y, -surface);\n        return result;\n    };\n    /**\n     * Solves quadratic equation\n     */\n    PyramidSeries.prototype.solveQuadraticEquation = function (a, b, c) {\n        var root1;\n        var root2;\n        var d = b * b - 4 * a * c;\n        if (d >= 0) {\n            var sd = Math.sqrt(d);\n            root1 = (-b - sd) / (2 * a);\n            root2 = (-b + sd) / (2 * a);\n            return Math.max(root1, root2);\n        }\n        return 0;\n    };\n    /**\n     * Renders a pyramid segment\n     */\n    PyramidSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw) {\n        if (!point.visible) {\n            removeElement(options.id);\n            return null;\n        }\n        options.d = this.getSegmentData(point, series, chart);\n        point.midAngle = 0;\n        var element = chart.renderer.drawPath(options);\n        element.setAttribute(\"tabindex\", point.index === 0 ? \"0\" : \"\");\n        element.setAttribute('aria-label', (point.x + \": \" + point.y + '%. ' + series.name));\n        appendChildElement(false, seriesGroup, element, redraw);\n        if (point.isExplode) {\n            chart.accBaseModule.explodePoints(point.index, chart, true);\n        }\n    };\n    /**\n     * To get the module name of the Pyramid series.\n     */\n    PyramidSeries.prototype.getModuleName = function () {\n        return 'PyramidSeries';\n    };\n    /**\n     * To destroy the pyramid series\n     *\n     * @returns {void}\n     * @private\n     */\n    PyramidSeries.prototype.destroy = function () {\n        /**\n         * Destroys the pyramid series\n         */\n    };\n    return PyramidSeries;\n}(TriangularBase));\nexport { PyramidSeries };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}