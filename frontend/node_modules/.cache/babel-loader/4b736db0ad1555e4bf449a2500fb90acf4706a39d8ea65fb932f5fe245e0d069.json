{"ast":null,"code":"/* eslint-disable jsdoc/require-returns */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\nimport { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * `DataLabel` module is used to render data label for the data point.\n */\nvar DataLabel = /** @class */function () {\n  /**\n   * Constructor for the data label module.\n   *\n   * @private\n   */\n  function DataLabel(chart) {\n    this.errorHeight = 0;\n    this.chart = chart;\n  }\n  DataLabel.prototype.initPrivateVariables = function (series, marker) {\n    var transform = '';\n    var clipPath = '';\n    var render = series.chart.renderer;\n    var index = series.index === undefined ? series.category : series.index;\n    if (series.chart.chartAreaType === 'Cartesian') {\n      transform = 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')';\n      clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n    }\n    if (marker.dataLabel.visible) {\n      series.shapeElement = render.createGroup({\n        'id': this.chart.element.id + 'ShapeGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n      });\n      series.textElement = render.createGroup({\n        'id': this.chart.element.id + 'TextGroup' + index,\n        'transform': transform,\n        'clip-path': clipPath\n      });\n      series.textElement.setAttribute('aria-hidden', 'true');\n    }\n    this.markerHeight = series.type === 'Scatter' || marker.visible ? marker.height / 2 : 0;\n    this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n    this.calculateErrorHeight(series, series.marker.dataLabel.position);\n    this.chartBackground = this.chart.chartArea.background === 'transparent' ? this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n  };\n  DataLabel.prototype.calculateErrorHeight = function (series, position) {\n    if (!series.errorBar.visible) {\n      return null;\n    } else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n      var direction = series.errorBar.direction;\n      var positiveHeight = this.chart.errorBarModule.positiveHeight;\n      var negativeHeight = this.chart.errorBarModule.negativeHeight;\n      if (this.isRectSeries(series)) {\n        if (position === 'Top' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n        if (position === 'Outer' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Plus') {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      } else {\n        if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n          if ((direction === 'Both' || direction === 'Plus') && !series.chart.isTransposed) {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n        if (position === 'Bottom' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      }\n    } else {\n      this.errorHeight = 0;\n    }\n  };\n  DataLabel.prototype.isRectSeries = function (series) {\n    return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea';\n  };\n  /**\n   * Render the data label for series.\n   *\n   * @returns {void}\n   */\n  DataLabel.prototype.render = function (series, chart, dataLabel) {\n    // initialize the private variable\n    this.initPrivateVariables(series, series.marker);\n    var rect;\n    var labelLocation = {\n      x: 0,\n      y: 0\n    };\n    var rgbValue;\n    var contrast;\n    var argsData;\n    var border;\n    var textSize;\n    var angle;\n    var degree;\n    this.inverted = chart.requireInvertedAxis;\n    this.yAxisInversed = series.yAxis.isAxisInverse;\n    var redraw = chart.redraw;\n    var isDataLabelOverlap = false;\n    var coordinatesAfterRotation = [];\n    var templateId = chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n    var element = createElement('div', {\n      id: templateId\n    });\n    var visiblePoints = getVisiblePoints(series);\n    var point;\n    var rectCenterX;\n    var rectCenterY;\n    // Data label point iteration started\n    for (var i = 0; i < visiblePoints.length; i++) {\n      point = visiblePoints[i];\n      if (!dataLabel.showZero && (point.y !== 0 || point.y === 0 && series.emptyPointSettings.mode === 'Zero')) {\n        return null;\n      }\n      this.margin = dataLabel.margin;\n      var labelText = [];\n      var labelLength = void 0;\n      var xPos = void 0;\n      var yPos = void 0;\n      var xValue = void 0;\n      var yValue = void 0;\n      var isRender = true;\n      var clip = series.clipRect;\n      var shapeRect = void 0;\n      isDataLabelOverlap = false;\n      angle = degree = dataLabel.angle;\n      border = {\n        width: dataLabel.border.width,\n        color: dataLabel.border.color\n      };\n      var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n      if (point.symbolLocations.length && point.symbolLocations[0] || series.type === 'BoxAndWhisker' && point.regions.length) {\n        labelText = getLabelText(point, series, chart);\n        labelLength = labelText.length;\n        for (var i_1 = 0; i_1 < labelLength; i_1++) {\n          argsData = {\n            cancel: false,\n            name: textRender,\n            series: series,\n            point: point,\n            text: labelText[i_1],\n            border: border,\n            color: dataLabel.fill,\n            template: dataLabel.template,\n            font: argsFont,\n            location: labelLocation,\n            textSize: measureText(labelText[i_1], dataLabel.font)\n          };\n          chart.trigger(textRender, argsData);\n          if (!argsData.cancel) {\n            this.fontBackground = argsData.color;\n            this.isDataLabelShape(argsData);\n            this.markerHeight = series.type === 'Bubble' ? point.regions[0].height / 2 : this.markerHeight;\n            if (argsData.template !== null) {\n              this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\n            } else {\n              textSize = measureText(argsData.text, dataLabel.font);\n              rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1);\n              // To check whether the polar radar chart datalabel intersects the axis label or not\n              if (chart.chartAreaType === 'PolarRadar') {\n                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\n                  var rectRegion = _a[_i];\n                  if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\n                    isRender = false;\n                    break;\n                  }\n                }\n              }\n              var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\n              //let notOverlapping: boolean;\n              if (dataLabel.enableRotation) {\n                var rectCoordinates = this.getRectanglePoints(rect);\n                rectCenterX = rect.x + rect.width / 2;\n                rectCenterY = rect.y + rect.height / 2;\n                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\n                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\n                if (!isDataLabelOverlap) {\n                  this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\n                  var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n                  for (var index = currentPointIndex; index >= 0; index--) {\n                    if (this.chart.rotatedDataLabelCollections[currentPointIndex] && this.chart.rotatedDataLabelCollections[index - 1] && isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                      isDataLabelOverlap = true;\n                      this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                      break;\n                    }\n                  }\n                }\n              } else {\n                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\n              }\n              if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\n                chart.dataLabelCollections.push(actualRect);\n                if (this.isShape) {\n                  shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n                  if (series.shapeElement) {\n                    series.shapeElement.appendChild(shapeRect);\n                  }\n                }\n                // Checking the font color\n                var backgroundColor = this.fontBackground === 'transparent' ? this.chart.theme.indexOf('Dark') > -1 || this.chart.theme == \"HighContrast\" ? 'black' : 'white' : this.fontBackground;\n                rgbValue = convertHexToColor(colorNameToHex(backgroundColor));\n                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                xPos = rect.x + this.margin.left + textSize.width / 2 + labelLocation.x;\n                yPos = rect.y + this.margin.top + textSize.height * 3 / 4 + labelLocation.y;\n                labelLocation = {\n                  x: 0,\n                  y: 0\n                };\n                if (angle !== 0 && dataLabel.enableRotation) {\n                  // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                  xValue = rectCenterX;\n                  //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                  // (dataLabel.margin.bottom) / 2;\n                  yValue = rectCenterY;\n                  degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;\n                } else {\n                  degree = 0;\n                  xValue = rect.x;\n                  yValue = rect.y;\n                }\n                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + xValue + ',' + yValue + ')', 'auto', degree), argsData.font, argsData.font.color || (contrast >= 128 || series.type === 'Hilo' ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas);\n              }\n            }\n          }\n        }\n      }\n    }\n    if (element.childElementCount) {\n      if (!chart.enableCanvas) {\n        appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw,\n        // eslint-disable-next-line @typescript-eslint/indent\n        false, 'x', 'y', null, '', false, false, null, chart.duration);\n      } else {\n        getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n      }\n    }\n  };\n  /**\n   * Get rect coordinates\n   */\n  DataLabel.prototype.getRectanglePoints = function (rect) {\n    var loc1 = new ChartLocation(rect.x, rect.y);\n    var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n    var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n    var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n    return [loc1, loc2, loc3, loc4];\n  };\n  DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n    for (var index = 0; index < rectCoordinates.length; index++) {\n      if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Render the data label template.\n   *\n   * @returns {void}\n   * @private\n   */\n  DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n    this.margin = {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    };\n    var clip = series.clipRect;\n    var childElement = createTemplate(createElement('div', {\n      id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_' + point.index + (labelIndex ? '_' + labelIndex : ''),\n      styles: 'position: absolute;background-color:' + data.color + ';' + getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n    }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n    this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n  };\n  DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n    var elementRect = measureElementRect(childElement, redraw, isReactCallback);\n    var rect = this.calculateTextPosition(point, series, {\n      width: elementRect.width,\n      height: elementRect.height\n    }, dataLabel, labelIndex);\n    var clipWidth = 0;\n    var clipHeight = 0;\n    var isOverlap = false;\n    if (isReactCallback) {\n      isOverlap = elementRect.width === 0 || elementRect.height === 0; // To check the data label already overlap before react callback call\n      // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n      //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n      // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n    }\n\n    childElement.style.left = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth + 'px';\n    childElement.style.top = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight + 'px';\n    var backgroundColor = this.fontBackground === 'transparent' ? this.chart.theme.indexOf('Dark') > -1 ? 'black' : 'white' : this.fontBackground;\n    var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));\n    var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n    var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n    childElement.style.color = dataLabel.font.color || (Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000) >= 128 ? 'black' : 'white');\n    if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) || dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined || withIn(point.yValue, series.yAxis.visibleRange) || series.type.indexOf('Stacking') > -1 || series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange)) && withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y && parseFloat(childElement.style.left) >= hAxis.rect.x && parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height && parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n      this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n      appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n      if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n        this.doDataLabelAnimation(series, childElement);\n      } else if (this.chart.enableCanvas) {\n        parentElement.appendChild(childElement);\n      }\n    }\n  };\n  DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n    var labelRegion = labelIndex > 1 ? series.type === 'Candle' ? point.regions[1] : point.regions[0] : point.regions[0];\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n    var location;\n    location = this.getLabelLocation(point, series, textSize, labelIndex);\n    var padding = 5;\n    var clipRect = series.clipRect;\n    // calculating alignment\n    if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n      this.locationX = location.x;\n      var alignmentValue = textSize.height + this.borderWidth * 2 + this.markerHeight + this.margin.bottom + this.margin.top + padding;\n      location.x = dataLabel.position === 'Auto' ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\n      // calculating position\n      location.y = !this.isRectSeries(series) || series.type === 'BoxAndWhisker' ? this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) : this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n      if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n        location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n      }\n    } else {\n      this.locationY = location.y;\n      var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n      location.x = dataLabel.position === 'Auto' ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n      location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n    }\n    var rect = calculateRect(location, textSize, this.margin);\n    // Checking the condition whether data Label has been exist the clip rect\n    if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) && !(rect.y > clipRect.y + clipRect.height || rect.x > clipRect.x + clipRect.width || rect.x + rect.width < 0 || rect.y + rect.height < 0)) {\n      rect.x = rect.x < 0 ? padding : rect.x;\n      rect.y = rect.y < 0 && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n      rect.x -= rect.x + rect.width > clipRect.x + clipRect.width ? rect.x + rect.width - (clipRect.x + clipRect.width) + padding : 0;\n      rect.y -= rect.y + rect.height > clipRect.y + clipRect.height ? rect.y + rect.height - (clipRect.y + clipRect.height) + padding : 0;\n      this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    }\n    var dataLabelOutRegion;\n    if (this.inverted && series.isRectSeries && rect.x + rect.width > labelRegion.x + labelRegion.width) {\n      dataLabelOutRegion = true;\n    }\n    this.fontBackground = dataLabelOutRegion ? this.chartBackground : this.fontBackground;\n    return rect;\n  };\n  // Calculation label location for polar column draw types\n  DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n    var padding = 5;\n    var columnRadius;\n    var chartWidth = this.chart.availableSize.width;\n    var alignmentSign = alignment === 'Center' ? 0 : alignment === 'Far' ? 1 : -1;\n    var angle = point.regionData.startAngle - 0.5 * Math.PI + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n    if (labelIndex === 0) {\n      columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    } else {\n      columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    }\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    if (series.drawType.indexOf('Stacking') > -1) {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.drawType.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    }\n    if (position === 'Outer') {\n      columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight : columnRadius - 2 * padding - this.markerHeight;\n    } else if (position === 'Middle') {\n      columnRadius = columnRadius / 2 + padding;\n      if (series.drawType === 'StackingColumn') {\n        columnRadius = point.regionData.innerRadius + (point.regionData.radius - point.regionData.innerRadius) / 2 + padding - size.height / 2;\n      }\n    } else if (position === 'Top') {\n      columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight : columnRadius + 2 * padding + this.markerHeight;\n    } else if (position === 'Bottom') {\n      columnRadius = 2 * padding;\n      columnRadius += series.drawType === 'StackingColumn' ? point.regionData.innerRadius + this.markerHeight : 0;\n    } else {\n      if (labelIndex === 0) {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding : series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n      } else {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n      }\n    }\n    columnRadius += alignmentValue * alignmentSign;\n    location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n    // To change x location based on text anchor for column and stackingcolumn chart\n    if (series.drawType === 'StackingColumn') {\n      location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 : location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x;\n    } else if (series.drawType === 'Column') {\n      location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 : location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x;\n    }\n    location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n    return location;\n  };\n  /**\n   * Get the label location\n   */\n  DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n    var location = new ChartLocation(0, 0);\n    var labelRegion = series.type === 'Candle' && labelIndex > 1 ? point.regions[1] : point.regions[0];\n    if (series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n    var xAxis = series.xAxis;\n    var yAxis = series.yAxis;\n    var isInverted = series.chart.requireInvertedAxis;\n    if (series.type === 'BoxAndWhisker') {\n      this.markerHeight = 0;\n      switch (labelIndex) {\n        case 0:\n          location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n          break;\n        case 1:\n          location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n          break;\n        case 2:\n          location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n          break;\n        case 3:\n          location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n          break;\n        case 4:\n          location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n          break;\n        default:\n          {\n            location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n            this.markerHeight = series.marker.height / 2;\n            break;\n          }\n      }\n      if (isInverted) {\n        location.y = point.regions[0].y + point.regions[0].height / 2;\n      } else {\n        location.x = point.regions[0].x + point.regions[0].width / 2;\n      }\n    } else if (labelIndex === 0 || labelIndex === 1) {\n      location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n    } else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n      location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n    } else if (isInverted) {\n      location = {\n        x: labelRegion.x + labelRegion.width / 2,\n        y: labelRegion.y\n      };\n    } else {\n      location = {\n        x: labelRegion.x + labelRegion.width,\n        y: labelRegion.y + labelRegion.height / 2\n      };\n    }\n    //Aligning the label at the beginning of the tick, when tick size is less than text size\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      if (series.chart.requireInvertedAxis) {\n        var height = labelRegion.height;\n        location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      } else {\n        var width = labelRegion.width;\n        location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      }\n    }\n    return location;\n  };\n  DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n    if (series.chart.chartAreaType === 'PolarRadar') {\n      return null;\n    }\n    var padding = 5;\n    var margin = this.margin;\n    var textLength = !this.inverted ? textSize.height : textSize.width;\n    var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 && Math.abs(rect.height - textSize.height) < padding ? 0 : padding);\n    if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.type.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    } else if (series.type === 'Waterfall') {\n      position = position === 'Auto' ? 'Middle' : position;\n    }\n    switch (position) {\n      case 'Bottom':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height + extraSpace + margin.top : labelLocation + rect.height - extraSpace - margin.bottom : isMinus ? labelLocation + rect.width - extraSpace - margin.left : labelLocation - rect.width + extraSpace + margin.right;\n        break;\n      case 'Middle':\n        labelLocation = labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height / 2 : labelLocation + rect.height / 2 : isMinus ? labelLocation + rect.width / 2 : labelLocation - rect.width / 2;\n        break;\n      case 'Auto':\n        labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n        break;\n      default:\n        extraSpace += this.errorHeight;\n        labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n        break;\n    }\n    var check = !this.inverted ? labelLocation < rect.y || labelLocation > rect.y + rect.height : labelLocation < rect.x || labelLocation > rect.x + rect.width;\n    this.fontBackground = check ? this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground : this.fontBackground === 'transparent' ? point.color || series.interior : this.fontBackground;\n    var seriesLength = series.chart.series.length;\n    if (position === 'Outer' && series.type.indexOf('Stacking') > -1 && seriesLength - 1 > series.index) {\n      var nextSeries = void 0;\n      var nextSeriesPoint = void 0;\n      for (var i = series.index + 1; i < seriesLength; i++) {\n        nextSeries = series.chart.series[i];\n        nextSeriesPoint = nextSeries.points[point.index];\n        if (nextSeries.type.indexOf('Stacking') > -1 && nextSeries.type.indexOf('100') === -1) {\n          this.fontBackground = nextSeriesPoint && (nextSeriesPoint.yValue < 0 && point.yValue < 0 || nextSeriesPoint.yValue > 0 && point.yValue > 0) ? nextSeriesPoint ? nextSeriesPoint.color : nextSeries.interior : this.fontBackground;\n          break;\n        }\n      }\n    }\n    return labelLocation;\n  };\n  DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n    var padding = 5;\n    if (series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea' && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n      position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n    }\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    switch (position) {\n      case 'Top':\n      case 'Outer':\n        labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding - this.errorHeight;\n        break;\n      case 'Bottom':\n        labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding + this.errorHeight;\n        break;\n      case 'Auto':\n        labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n        break;\n    }\n    return labelLocation;\n  };\n  DataLabel.prototype.isDataLabelShape = function (style) {\n    this.isShape = style.color !== 'transparent' || style.border.width > 0;\n    this.borderWidth = style.border.width;\n    if (!this.isShape) {\n      this.margin = {\n        left: 0,\n        right: 0,\n        bottom: 0,\n        top: 0\n      };\n    }\n  };\n  DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n    var location;\n    var labelRect;\n    var isOverLap = true;\n    var position = 0;\n    var collection = this.chart.dataLabelCollections;\n    var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n    while (isOverLap && position < finalPosition) {\n      var actualPosition = this.getPosition(position);\n      if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n        actualPosition = 'Top';\n        position++;\n      }\n      location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n      if (!this.inverted) {\n        labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n        isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n      } else {\n        labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n        isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.x + labelRect.width > series.clipRect.width;\n      }\n      position++;\n    }\n    return location;\n  };\n  // alignment calculation assigned here\n  DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n    switch (alignment) {\n      case 'Far':\n        labelLocation = !this.inverted ? isMinus ? labelLocation + value : labelLocation - value : isMinus ? labelLocation - value : labelLocation + value;\n        break;\n      case 'Near':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - value : labelLocation + value : isMinus ? labelLocation + value : labelLocation - value;\n        break;\n      // eslint-disable-next-line no-self-assign\n      case 'Center':\n        labelLocation = labelLocation;\n        break;\n    }\n    return labelLocation;\n  };\n  //calculation for top and outer position of datalabel for rect series\n  DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n    var margin = this.margin;\n    var top;\n    switch (series.type) {\n      case 'RangeColumn':\n      case 'RangeArea':\n      case 'SplineRangeArea':\n      case 'Hilo':\n        top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        break;\n      case 'Candle':\n        top = (index === 0 || index === 2) && !this.yAxisInversed || (index === 1 || index === 3) && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n        break;\n      case 'HiloOpenClose':\n        if (index <= 1) {\n          top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n          location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        } else {\n          if (this.yAxisInversed) {\n            location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n          } else {\n            location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n          }\n        }\n        break;\n      default:\n        if (isMinus && position === 'Top' || !isMinus && position === 'Outer') {\n          location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.left + this.markerHeight;\n        } else {\n          location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n        }\n        break;\n    }\n    return location;\n  };\n  /**\n   * Updates the label location\n   */\n  DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n    if (inside === void 0) {\n      inside = false;\n    }\n    if (!this.inverted) {\n      if (top) {\n        location = position === 'Outer' && !inside ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.top + this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location + rect.height + extraSpace + margin.top + this.markerHeight : location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n      }\n    } else {\n      if (top) {\n        location = position === 'Outer' && !inside ? location + extraSpace + margin.left + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location - rect.width - extraSpace - margin.right - this.markerHeight : location - rect.width + extraSpace + margin.left + this.markerHeight;\n      }\n    }\n    return location;\n  };\n  DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n    var points = series.points;\n    var index = point.index;\n    var yValue = points[index].yValue;\n    var position;\n    var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n    var previousPoint = index > 0 ? points[index - 1] : null;\n    var yLocation;\n    var isOverLap = true;\n    var labelRect;\n    var isBottom;\n    var positionIndex;\n    var collection = this.chart.dataLabelCollections;\n    if (series.type === 'Bubble') {\n      position = 'Top';\n    } else if (series.type.indexOf('Step') > -1) {\n      position = 'Top';\n      if (index) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue !== this.yAxisInversed || yValue === previousPoint.yValue ? 'Top' : 'Bottom';\n      }\n    } else if (series.type === 'BoxAndWhisker') {\n      if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n        position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n      } else if (labelIndex === 2 || labelIndex === 4) {\n        position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n      } else {\n        isOverLap = false;\n        position = 'Middle';\n        yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n      }\n    } else {\n      if (index === 0) {\n        position = !nextPoint || !nextPoint.visible || yValue > nextPoint.yValue || yValue < nextPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else if (index === points.length - 1) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue || yValue < previousPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else {\n        if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n          position = 'Top';\n        } else if (!nextPoint.visible || !previousPoint) {\n          position = nextPoint.yValue > yValue || previousPoint && previousPoint.yValue > yValue ? 'Bottom' : 'Top';\n        } else {\n          var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n          var intersectY = slope * index + (nextPoint.yValue - slope * (index + 1));\n          position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' : intersectY < yValue ? 'Bottom' : 'Top';\n        }\n      }\n    }\n    isBottom = position === 'Bottom';\n    positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n    while (isOverLap && positionIndex < 4) {\n      yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n      labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n      isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y + labelRect.height > series.clipRect.height;\n      positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n      isBottom = false;\n    }\n    return yLocation;\n  };\n  /**\n   * Animates the data label.\n   *\n   * @param  {Series} series - Data label of the series gets animated.\n   * @returns {void}\n   */\n  DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n    var shapeElements = series.shapeElement.childNodes;\n    var textNode = series.textElement.childNodes;\n    var delay = series.animation.delay + series.animation.duration;\n    var duration = series.chart.animated ? series.chart.duration : 200;\n    var location;\n    var length = element ? 1 : textNode.length;\n    var tempElement;\n    for (var i = 0; i < length; i++) {\n      tempElement = textNode[i];\n      if (element) {\n        element.style.visibility = 'hidden';\n        templateAnimate(element, delay, duration, 'ZoomIn');\n      } else {\n        location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n        markerAnimate(tempElement, delay, duration, series, null, location, true);\n        if (shapeElements[i]) {\n          tempElement = shapeElements[i];\n          location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n          markerAnimate(tempElement, delay, duration, series, null, location, true);\n        }\n      }\n    }\n  };\n  DataLabel.prototype.getPosition = function (index) {\n    return ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index];\n  };\n  /**\n   * Get module name.\n   */\n  DataLabel.prototype.getModuleName = function () {\n    // Returns the module name\n    return 'DataLabel';\n  };\n  /**\n   * To destroy the dataLabel for series.\n   *\n   * @returns {void}\n   * @private\n   */\n  DataLabel.prototype.destroy = function () {\n    // Destroy method performed here\n  };\n  return DataLabel;\n}();\nexport { DataLabel };","map":{"version":3,"names":["ChartLocation","RectOption","isCollide","isOverlap","markerAnimate","appendChildElement","getVisiblePoints","getLabelText","convertHexToColor","calculateRect","textElement","colorNameToHex","measureText","TextOption","Rect","textRender","createTemplate","getFontStyle","getElement","measureElementRect","templateAnimate","withIn","withInBounds","createElement","getValue","extend","getPoint","getRotatedRectangleCoordinates","isRotatedRectIntersect","DataLabel","chart","errorHeight","prototype","initPrivateVariables","series","marker","transform","clipPath","render","renderer","index","undefined","category","chartAreaType","clipRect","x","y","element","id","dataLabel","visible","shapeElement","createGroup","setAttribute","markerHeight","type","height","commonId","calculateErrorHeight","position","chartBackground","chartArea","background","themeStyle","errorBar","direction","positiveHeight","errorBarModule","negativeHeight","isRectSeries","isTransposed","rect","labelLocation","rgbValue","contrast","argsData","border","textSize","angle","degree","inverted","requireInvertedAxis","yAxisInversed","yAxis","isAxisInverse","redraw","isDataLabelOverlap","coordinatesAfterRotation","templateId","visiblePoints","point","rectCenterX","rectCenterY","i","length","showZero","emptyPointSettings","mode","margin","labelText","labelLength","xPos","yPos","xValue","yValue","isRender","clip","shapeRect","width","color","argsFont","font","symbolLocations","regions","i_1","cancel","name","text","fill","template","location","trigger","fontBackground","isDataLabelShape","createDataLabelTemplate","calculateTextPosition","_i","_a","chartAxisLayoutPanel","visibleAxisLabelRect","rectRegion","actualRect","enableRotation","rectCoordinates","getRectanglePoints","isDataLabelOverlapWithChartBound","rotatedDataLabelCollections","push","currentPointIndex","dataLabelCollections","labelIntersectAction","isShape","drawRectangle","opacity","rx","ry","Int32Array","appendChild","backgroundColor","theme","indexOf","Math","round","r","g","b","left","top","duration","enableCanvas","childElementCount","loc1","loc2","loc3","loc4","initialClipRect","parentElement","data","labelIndex","right","bottom","childElement","styles","calculateTemplateLabelSize","isReactCallback","elementRect","clipWidth","clipHeight","style","vAxis","xAxis","hAxis","seriesType","visibleRange","stackedValues","endValues","parseFloat","animation","enable","animateSeries","doDataLabelAnimation","labelRegion","getLabelLocation","padding","locationX","alignmentValue","borderWidth","calculateAlignment","alignment","calculatePathPosition","calculateRectPosition","calculatePolarRectPosition","locationY","dataLabelOutRegion","size","columnRadius","chartWidth","availableSize","alignmentSign","regionData","startAngle","PI","endAngle","radius","innerRadius","drawType","cos","sin","isInverted","median","maximum","minimum","upperQuartile","lowerQuartile","outliers","isMinus","textLength","extraSpace","abs","calculateRectActualPosition","calculateTopAndOuterPosition","check","interior","seriesLength","nextSeries","nextSeriesPoint","points","calculatePathActualPosition","labelRect","isOverLap","collection","finalPosition","actualPosition","getPosition","value","updateLabelLocation","inside","markerSize","nextPoint","previousPoint","yLocation","isBottom","positionIndex","slope","intersectY","shapeElements","childNodes","textNode","delay","animated","tempElement","visibility","getAttribute","getModuleName","destroy"],"sources":["/Users/thonghoangdanh/FullStack/birdnest/node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js"],"sourcesContent":["/* eslint-disable jsdoc/require-returns */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\nimport { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * `DataLabel` module is used to render data label for the data point.\n */\nvar DataLabel = /** @class */ (function () {\n    /**\n     * Constructor for the data label module.\n     *\n     * @private\n     */\n    function DataLabel(chart) {\n        this.errorHeight = 0;\n        this.chart = chart;\n    }\n    DataLabel.prototype.initPrivateVariables = function (series, marker) {\n        var transform = '';\n        var clipPath = '';\n        var render = series.chart.renderer;\n        var index = (series.index === undefined) ? series.category : series.index;\n        if (series.chart.chartAreaType === 'Cartesian') {\n            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';\n            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n        }\n        if (marker.dataLabel.visible) {\n            series.shapeElement = render.createGroup({\n                'id': this.chart.element.id + 'ShapeGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n            });\n            series.textElement = render.createGroup({\n                'id': this.chart.element.id + 'TextGroup' + index,\n                'transform': transform,\n                'clip-path': clipPath\n            });\n            series.textElement.setAttribute('aria-hidden', 'true');\n        }\n        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;\n        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n        this.calculateErrorHeight(series, series.marker.dataLabel.position);\n        this.chartBackground = this.chart.chartArea.background === 'transparent' ?\n            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n    };\n    DataLabel.prototype.calculateErrorHeight = function (series, position) {\n        if (!series.errorBar.visible) {\n            return null;\n        }\n        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n            var direction = series.errorBar.direction;\n            var positiveHeight = this.chart.errorBarModule.positiveHeight;\n            var negativeHeight = this.chart.errorBarModule.negativeHeight;\n            if (this.isRectSeries(series)) {\n                if (position === 'Top' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Outer' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Plus') {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n            else {\n                if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Bottom' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n        }\n        else {\n            this.errorHeight = 0;\n        }\n    };\n    DataLabel.prototype.isRectSeries = function (series) {\n        return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea';\n    };\n    /**\n     * Render the data label for series.\n     *\n     * @returns {void}\n     */\n    DataLabel.prototype.render = function (series, chart, dataLabel) {\n        // initialize the private variable\n        this.initPrivateVariables(series, series.marker);\n        var rect;\n        var labelLocation = { x: 0, y: 0 };\n        var rgbValue;\n        var contrast;\n        var argsData;\n        var border;\n        var textSize;\n        var angle;\n        var degree;\n        this.inverted = chart.requireInvertedAxis;\n        this.yAxisInversed = series.yAxis.isAxisInverse;\n        var redraw = chart.redraw;\n        var isDataLabelOverlap = false;\n        var coordinatesAfterRotation = [];\n        var templateId = chart.element.id + '_Series_' +\n            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n        var element = createElement('div', {\n            id: templateId\n        });\n        var visiblePoints = getVisiblePoints(series);\n        var point;\n        var rectCenterX;\n        var rectCenterY;\n        // Data label point iteration started\n        for (var i = 0; i < visiblePoints.length; i++) {\n            point = visiblePoints[i];\n            if (!dataLabel.showZero && ((point.y !== 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {\n                return null;\n            }\n            this.margin = dataLabel.margin;\n            var labelText = [];\n            var labelLength = void 0;\n            var xPos = void 0;\n            var yPos = void 0;\n            var xValue = void 0;\n            var yValue = void 0;\n            var isRender = true;\n            var clip = series.clipRect;\n            var shapeRect = void 0;\n            isDataLabelOverlap = false;\n            angle = degree = dataLabel.angle;\n            border = { width: dataLabel.border.width, color: dataLabel.border.color };\n            var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));\n            if ((point.symbolLocations.length && point.symbolLocations[0]) ||\n                (series.type === 'BoxAndWhisker' && point.regions.length)) {\n                labelText = getLabelText(point, series, chart);\n                labelLength = labelText.length;\n                for (var i_1 = 0; i_1 < labelLength; i_1++) {\n                    argsData = {\n                        cancel: false, name: textRender, series: series,\n                        point: point, text: labelText[i_1], border: border,\n                        color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,\n                        textSize: measureText(labelText[i_1], dataLabel.font)\n                    };\n                    chart.trigger(textRender, argsData);\n                    if (!argsData.cancel) {\n                        this.fontBackground = argsData.color;\n                        this.isDataLabelShape(argsData);\n                        this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;\n                        if (argsData.template !== null) {\n                            this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\n                        }\n                        else {\n                            textSize = measureText(argsData.text, dataLabel.font);\n                            rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1);\n                            // To check whether the polar radar chart datalabel intersects the axis label or not\n                            if (chart.chartAreaType === 'PolarRadar') {\n                                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\n                                    var rectRegion = _a[_i];\n                                    if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\n                                        isRender = false;\n                                        break;\n                                    }\n                                }\n                            }\n                            var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\n                            //let notOverlapping: boolean;\n                            if (dataLabel.enableRotation) {\n                                var rectCoordinates = this.getRectanglePoints(rect);\n                                rectCenterX = rect.x + (rect.width / 2);\n                                rectCenterY = (rect.y + (rect.height / 2));\n                                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\n                                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\n                                if (!isDataLabelOverlap) {\n                                    this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\n                                    var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n                                    for (var index = currentPointIndex; index >= 0; index--) {\n                                        if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&\n                                            this.chart.rotatedDataLabelCollections[index - 1] &&\n                                            isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                                            isDataLabelOverlap = true;\n                                            this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            else {\n                                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\n                            }\n                            if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\n                                chart.dataLabelCollections.push(actualRect);\n                                if (this.isShape) {\n                                    shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n                                    if (series.shapeElement) {\n                                        series.shapeElement.appendChild(shapeRect);\n                                    }\n                                }\n                                // Checking the font color\n                                var backgroundColor = this.fontBackground === 'transparent' ? ((this.chart.theme.indexOf('Dark') > -1 || this.chart.theme == \"HighContrast\") ? 'black' : 'white') : this.fontBackground;\n                                rgbValue = convertHexToColor(colorNameToHex(backgroundColor));\n                                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                                xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;\n                                yPos = (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;\n                                labelLocation = { x: 0, y: 0 };\n                                if (angle !== 0 && dataLabel.enableRotation) {\n                                    // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                                    xValue = rectCenterX;\n                                    //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                                    // (dataLabel.margin.bottom) / 2;\n                                    yValue = rectCenterY;\n                                    degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n                                }\n                                else {\n                                    degree = 0;\n                                    xValue = rect.x;\n                                    yValue = rect.y;\n                                }\n                                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color ||\n                                    ((contrast >= 128 || series.type === 'Hilo') ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (element.childElementCount) {\n            if (!chart.enableCanvas) {\n                appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, \n                // eslint-disable-next-line @typescript-eslint/indent\n                false, 'x', 'y', null, '', false, false, null, chart.duration);\n            }\n            else {\n                getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n            }\n        }\n    };\n    /**\n     * Get rect coordinates\n     */\n    DataLabel.prototype.getRectanglePoints = function (rect) {\n        var loc1 = new ChartLocation(rect.x, rect.y);\n        var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n        var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n        return [loc1, loc2, loc3, loc4];\n    };\n    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n        for (var index = 0; index < rectCoordinates.length; index++) {\n            if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Render the data label template.\n     *\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        var clip = series.clipRect;\n        var childElement = createTemplate(createElement('div', {\n            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'\n                + point.index + (labelIndex ? ('_' + labelIndex) : ''),\n            styles: 'position: absolute;background-color:' + data.color + ';' +\n                getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n        }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n    };\n    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n        var elementRect = measureElementRect(childElement, redraw, isReactCallback);\n        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);\n        var clipWidth = 0;\n        var clipHeight = 0;\n        var isOverlap = false;\n        if (isReactCallback) {\n            isOverlap = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call\n            // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n            //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n            // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n        }\n        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';\n        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';\n        var backgroundColor = this.fontBackground === 'transparent' ? (this.chart.theme.indexOf('Dark') > -1 ? 'black' : 'white') : this.fontBackground;\n        var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));\n        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n        childElement.style.color = dataLabel.font.color ||\n            ((Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000)) >= 128 ? 'black' : 'white');\n        if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) ||\n            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||\n            withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||\n            (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&\n            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&\n            parseFloat(childElement.style.left) >= hAxis.rect.x &&\n            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&\n            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n            appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n                this.doDataLabelAnimation(series, childElement);\n            }\n            else if (this.chart.enableCanvas) {\n                parentElement.appendChild(childElement);\n            }\n        }\n    };\n    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var location;\n        location = this.getLabelLocation(point, series, textSize, labelIndex);\n        var padding = 5;\n        var clipRect = series.clipRect;\n        // calculating alignment\n        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n            this.locationX = location.x;\n            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +\n                this.margin.bottom + this.margin.top + padding;\n            location.x = (dataLabel.position === 'Auto') ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\n            // calculating position\n            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?\n                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :\n                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n            }\n        }\n        else {\n            this.locationY = location.y;\n            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n            location.x = dataLabel.position === 'Auto' ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n        }\n        var rect = calculateRect(location, textSize, this.margin);\n        // Checking the condition whether data Label has been exist the clip rect\n        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&\n            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||\n                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {\n            rect.x = rect.x < 0 ? padding : rect.x;\n            rect.y = (rect.y < 0) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)\n                - (clipRect.x + clipRect.width) + padding : 0;\n            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)\n                - (clipRect.y + clipRect.height) + padding : 0;\n            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        }\n        var dataLabelOutRegion;\n        if (this.inverted && series.isRectSeries && (rect.x + rect.width > labelRegion.x + labelRegion.width)) {\n            dataLabelOutRegion = true;\n        }\n        this.fontBackground = dataLabelOutRegion ? this.chartBackground : this.fontBackground;\n        return rect;\n    };\n    // Calculation label location for polar column draw types\n    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n        var padding = 5;\n        var columnRadius;\n        var chartWidth = this.chart.availableSize.width;\n        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);\n        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n        if (labelIndex === 0) {\n            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        else {\n            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        if (series.drawType.indexOf('Stacking') > -1) {\n            position = position === 'Outer' ? 'Top' : position;\n        }\n        else if (series.drawType.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        if (position === 'Outer') {\n            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :\n                columnRadius - 2 * padding - this.markerHeight;\n        }\n        else if (position === 'Middle') {\n            columnRadius = columnRadius / 2 + padding;\n            if (series.drawType === 'StackingColumn') {\n                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)\n                    + padding - (size.height / 2);\n            }\n        }\n        else if (position === 'Top') {\n            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :\n                columnRadius + 2 * padding + this.markerHeight;\n        }\n        else if (position === 'Bottom') {\n            columnRadius = 2 * padding;\n            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;\n        }\n        else {\n            if (labelIndex === 0) {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :\n                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n            }\n            else {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n            }\n        }\n        columnRadius += (alignmentValue * alignmentSign);\n        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n        // To change x location based on text anchor for column and stackingcolumn chart\n        if (series.drawType === 'StackingColumn') {\n            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);\n        }\n        else if (series.drawType === 'Column') {\n            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);\n        }\n        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n        return location;\n    };\n    /**\n     * Get the label location\n     */\n    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n        var location = new ChartLocation(0, 0);\n        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];\n        if (series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var xAxis = series.xAxis;\n        var yAxis = series.yAxis;\n        var isInverted = series.chart.requireInvertedAxis;\n        if (series.type === 'BoxAndWhisker') {\n            this.markerHeight = 0;\n            switch (labelIndex) {\n                case 0:\n                    location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n                    break;\n                case 1:\n                    location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n                    break;\n                case 2:\n                    location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n                    break;\n                case 3:\n                    location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n                    break;\n                case 4:\n                    location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n                    break;\n                default: {\n                    location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n                    this.markerHeight = series.marker.height / 2;\n                    break;\n                }\n            }\n            if (isInverted) {\n                location.y = point.regions[0].y + (point.regions[0].height / 2);\n            }\n            else {\n                location.x = point.regions[0].x + (point.regions[0].width / 2);\n            }\n        }\n        else if (labelIndex === 0 || labelIndex === 1) {\n            location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n        }\n        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n            location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n        }\n        else if (isInverted) {\n            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };\n        }\n        else {\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\n        }\n        //Aligning the label at the beginning of the tick, when tick size is less than text size\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            if (series.chart.requireInvertedAxis) {\n                var height = labelRegion.height;\n                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n            else {\n                var width = labelRegion.width;\n                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n        if (series.chart.chartAreaType === 'PolarRadar') {\n            return null;\n        }\n        var padding = 5;\n        var margin = this.margin;\n        var textLength = !this.inverted ? textSize.height : textSize.width;\n        var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 &&\n            (Math.abs(rect.height - textSize.height) < padding) ? 0 : padding);\n        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n            position = (position === 'Outer') ? 'Top' : position;\n        }\n        else if (series.type.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        else if (series.type === 'Waterfall') {\n            position = position === 'Auto' ? 'Middle' : position;\n        }\n        switch (position) {\n            case 'Bottom':\n                labelLocation = !this.inverted ?\n                    isMinus ? (labelLocation - rect.height + extraSpace + margin.top) :\n                        (labelLocation + rect.height - extraSpace - margin.bottom) :\n                    isMinus ? (labelLocation + rect.width - extraSpace - margin.left) :\n                        (labelLocation - rect.width + extraSpace + margin.right);\n                break;\n            case 'Middle':\n                labelLocation = labelLocation = !this.inverted ?\n                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :\n                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));\n                break;\n            case 'Auto':\n                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n                break;\n            default:\n                extraSpace += this.errorHeight;\n                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n                break;\n        }\n        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :\n            (labelLocation < rect.x || labelLocation > rect.x + rect.width);\n        this.fontBackground = check ?\n            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)\n            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;\n        var seriesLength = series.chart.series.length;\n        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {\n            var nextSeries = void 0;\n            var nextSeriesPoint = void 0;\n            for (var i = series.index + 1; i < seriesLength; i++) {\n                nextSeries = series.chart.series[i];\n                nextSeriesPoint = nextSeries.points[point.index];\n                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {\n                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||\n                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :\n                        nextSeries.interior) : this.fontBackground;\n                    break;\n                }\n            }\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n        var padding = 5;\n        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea')\n            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        switch (position) {\n            case 'Top':\n            case 'Outer':\n                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -\n                    this.errorHeight;\n                break;\n            case 'Bottom':\n                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +\n                    this.errorHeight;\n                break;\n            case 'Auto':\n                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n                break;\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.isDataLabelShape = function (style) {\n        this.isShape = (style.color !== 'transparent' || style.border.width > 0);\n        this.borderWidth = style.border.width;\n        if (!this.isShape) {\n            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        }\n    };\n    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n        var location;\n        var labelRect;\n        var isOverLap = true;\n        var position = 0;\n        var collection = this.chart.dataLabelCollections;\n        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n        while (isOverLap && position < finalPosition) {\n            var actualPosition = this.getPosition(position);\n            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n                actualPosition = 'Top';\n                position++;\n            }\n            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n            if (!this.inverted) {\n                labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n                isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n            }\n            else {\n                labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n                isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) ||\n                    labelRect.x + labelRect.width > series.clipRect.width;\n            }\n            position++;\n        }\n        return location;\n    };\n    // alignment calculation assigned here\n    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n        switch (alignment) {\n            case 'Far':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :\n                    (isMinus ? labelLocation - value : labelLocation + value);\n                break;\n            case 'Near':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :\n                    (isMinus ? labelLocation + value : labelLocation - value);\n                break;\n            // eslint-disable-next-line no-self-assign\n            case 'Center':\n                labelLocation = labelLocation;\n                break;\n        }\n        return labelLocation;\n    };\n    //calculation for top and outer position of datalabel for rect series\n    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n        var margin = this.margin;\n        var top;\n        switch (series.type) {\n            case 'RangeColumn':\n            case 'RangeArea':\n            case 'SplineRangeArea':\n            case 'Hilo':\n                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                break;\n            case 'Candle':\n                top = (index === 0 || index === 2) && !this.yAxisInversed\n                    || (index === 1 || index === 3) && this.yAxisInversed;\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n                break;\n            case 'HiloOpenClose':\n                if (index <= 1) {\n                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                }\n                else {\n                    if (this.yAxisInversed) {\n                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n                    }\n                    else {\n                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n                    }\n                }\n                break;\n            default:\n                if ((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) {\n                    location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight :\n                        location + extraSpace + margin.left + this.markerHeight;\n                }\n                else {\n                    location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight :\n                        location - extraSpace - margin.right - this.markerHeight;\n                }\n                break;\n        }\n        return location;\n    };\n    /**\n     * Updates the label location\n     */\n    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n        if (inside === void 0) { inside = false; }\n        if (!this.inverted) {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location - extraSpace - margin.bottom - this.markerHeight :\n                    location + extraSpace + margin.top + this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location + rect.height + extraSpace + margin.top + this.markerHeight :\n                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n            }\n        }\n        else {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location + extraSpace + margin.left + this.markerHeight :\n                    location - extraSpace - margin.right - this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location - rect.width - extraSpace - margin.right - this.markerHeight :\n                    location - rect.width + extraSpace + margin.left + this.markerHeight;\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n        var points = series.points;\n        var index = point.index;\n        var yValue = points[index].yValue;\n        var position;\n        var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n        var previousPoint = index > 0 ? points[index - 1] : null;\n        var yLocation;\n        var isOverLap = true;\n        var labelRect;\n        var isBottom;\n        var positionIndex;\n        var collection = this.chart.dataLabelCollections;\n        if (series.type === 'Bubble') {\n            position = 'Top';\n        }\n        else if (series.type.indexOf('Step') > -1) {\n            position = 'Top';\n            if (index) {\n                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)\n                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';\n            }\n        }\n        else if (series.type === 'BoxAndWhisker') {\n            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n                position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n            }\n            else if (labelIndex === 2 || labelIndex === 4) {\n                position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n            }\n            else {\n                isOverLap = false;\n                position = 'Middle';\n                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n            }\n        }\n        else {\n            if (index === 0) {\n                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||\n                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else if (index === points.length - 1) {\n                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||\n                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else {\n                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n                    position = 'Top';\n                }\n                else if (!nextPoint.visible || !previousPoint) {\n                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?\n                        'Bottom' : 'Top';\n                }\n                else {\n                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));\n                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :\n                        intersectY < yValue ? 'Bottom' : 'Top';\n                }\n            }\n        }\n        isBottom = position === 'Bottom';\n        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n        while (isOverLap && positionIndex < 4) {\n            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n            labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n            isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect)\n                || (labelRect.y + labelRect.height) > series.clipRect.height;\n            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n            isBottom = false;\n        }\n        return yLocation;\n    };\n    /**\n     * Animates the data label.\n     *\n     * @param  {Series} series - Data label of the series gets animated.\n     * @returns {void}\n     */\n    DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n        var shapeElements = series.shapeElement.childNodes;\n        var textNode = series.textElement.childNodes;\n        var delay = series.animation.delay + series.animation.duration;\n        var duration = series.chart.animated ? series.chart.duration : 200;\n        var location;\n        var length = element ? 1 : textNode.length;\n        var tempElement;\n        for (var i = 0; i < length; i++) {\n            tempElement = textNode[i];\n            if (element) {\n                element.style.visibility = 'hidden';\n                templateAnimate(element, delay, duration, 'ZoomIn');\n            }\n            else {\n                location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                markerAnimate(tempElement, delay, duration, series, null, location, true);\n                if (shapeElements[i]) {\n                    tempElement = shapeElements[i];\n                    location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                    markerAnimate(tempElement, delay, duration, series, null, location, true);\n                }\n            }\n        }\n    };\n    DataLabel.prototype.getPosition = function (index) {\n        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);\n    };\n    /**\n     * Get module name.\n     */\n    DataLabel.prototype.getModuleName = function () {\n        // Returns the module name\n        return 'DataLabel';\n    };\n    /**\n     * To destroy the dataLabel for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.destroy = function () {\n        // Destroy method performed here\n    };\n    return DataLabel;\n}());\nexport { DataLabel };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}