{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { RectOption, appendChildElement, getElement, appendClipElement } from '../../common/utils/helper';\nimport { findlElement, drawSymbol, markerAnimate, CircleOption } from '../../common/utils/helper';\nimport { PathOption, Size } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { pointRender } from '../../common/model/constants';\nimport { MarkerExplode } from './marker-explode';\nimport { getSaturationColor } from '../../common/utils/helper';\n/**\n * Marker module used to render the marker for line type series.\n */\nvar Marker = /** @class */function (_super) {\n  __extends(Marker, _super);\n  /**\n   * Constructor for the marker module.\n   *\n   * @private\n   */\n  function Marker(chart) {\n    var _this = _super.call(this, chart) || this;\n    _this.addEventListener();\n    return _this;\n  }\n  /**\n   * Render the marker for series.\n   *\n   * @returns {void}\n   * @private\n   */\n  Marker.prototype.render = function (series) {\n    var _this = this;\n    var redraw = series.chart.redraw;\n    this.createElement(series, redraw);\n    var _loop_1 = function (point) {\n      if (point.visible && point.symbolLocations && point.symbolLocations.length) {\n        point.symbolLocations.map(function (location, index) {\n          if (series.marker.shape !== 'None') {\n            _this.renderMarker(series, point, location, index, redraw);\n          }\n        });\n      }\n    };\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n      _loop_1(point);\n    }\n  };\n  Marker.prototype.renderMarker = function (series, point, location, index, redraw) {\n    var seriesIndex = series.index === undefined ? series.category : series.index;\n    var marker = series.marker;\n    var border = {\n      color: marker.border.color,\n      width: marker.border.width\n    };\n    var borderColor = marker.border.color;\n    var previousLocation;\n    var previousPath;\n    var circlePath;\n    var shapeOption;\n    location.x = location.x + marker.offset.x;\n    location.y = location.y - marker.offset.y;\n    var isBoxPlot = series.type === 'BoxAndWhisker';\n    var fill = marker.fill || (isBoxPlot || series.marker.isFilled ? point.interior || series.interior : '#ffffff');\n    var markerElement;\n    var parentElement = isBoxPlot ? findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index) : series.symbolElement;\n    border.color = borderColor || series.setPointColor(point, series.interior);\n    var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' + (index ? index : '');\n    var argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: point.isEmpty ? series.emptyPointSettings.fill || fill : fill,\n      border: {\n        color: series.type === 'BoxAndWhisker' ? !isNullOrUndefined(borderColor) && borderColor !== 'transparent' ? borderColor : getSaturationColor(fill, -0.6) : border.color,\n        width: border.width\n      },\n      height: marker.height,\n      width: marker.width,\n      shape: marker.shape\n    };\n    argsData.border = series.setBorderColor(point, {\n      width: argsData.border.width,\n      color: argsData.border.color\n    });\n    if (!series.isRectSeries || series.type === 'BoxAndWhisker') {\n      this.chart.trigger(pointRender, argsData);\n      point.color = argsData.fill;\n    }\n    point.color = argsData.fill;\n    if (!argsData.cancel) {\n      var y = void 0;\n      if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn' || series.type === 'SplineRangeArea') {\n        y = index ? point.low : point.high;\n      } else if (isBoxPlot) {\n        y = point.outliers[index];\n      } else {\n        y = point.y;\n      }\n      var markerFill = argsData.point.marker.fill || argsData.fill;\n      var markerBorder = void 0;\n      if (!isNullOrUndefined(argsData.point.marker.border)) {\n        markerBorder = {\n          color: argsData.point.marker.border.color || argsData.border.color,\n          width: argsData.point.marker.border.width || argsData.border.width\n        };\n      } else {\n        markerBorder = {\n          color: argsData.border.color,\n          width: argsData.border.width\n        };\n      }\n      var markerWidth = argsData.point.marker.width || argsData.width;\n      var markerHeight = argsData.point.marker.height || argsData.height;\n      var markerOpacity = argsData.point.marker.opacity || marker.opacity;\n      var markerShape = argsData.point.marker.shape || argsData.shape;\n      var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\n      shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, null);\n      if (parentElement !== undefined && parentElement !== null || this.chart.enableCanvas) {\n        if (redraw && getElement(shapeOption.id)) {\n          markerElement = getElement(shapeOption.id);\n          circlePath = markerShape === 'Circle' ? 'c' : '';\n          previousLocation = {\n            x: +markerElement.getAttribute(circlePath + 'x'),\n            y: +markerElement.getAttribute(circlePath + 'y')\n          };\n          previousPath = markerElement.getAttribute('d');\n        }\n        markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);\n        if (markerElement) {\n          markerElement.setAttribute('aria-label', point.x + \": \" + point.y + ', ' + series.name);\n        }\n        appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);\n      }\n      point.marker = {\n        border: markerBorder,\n        fill: markerFill,\n        height: markerHeight,\n        visible: true,\n        shape: markerShape,\n        width: markerWidth,\n        imageUrl: imageURL\n      };\n    } else {\n      location = null;\n      point.marker = {\n        visible: false\n      };\n    }\n  };\n  Marker.prototype.createElement = function (series, redraw) {\n    var markerClipRect;\n    var marker = series.marker;\n    // 8 for extend border value 5 for extend size value\n    var explodeValue = marker.border.width + 8 + 5;\n    var render = series.chart.svgRenderer;\n    var index = series.index === undefined ? series.category : series.index;\n    var options;\n    var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')' : '';\n    if (marker.visible) {\n      var markerHeight = (marker.height + explodeValue) / 2;\n      var markerWidth = (marker.width + explodeValue) / 2;\n      if (series.chart.chartAreaType === 'Cartesian') {\n        options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, {\n          x: -markerWidth,\n          y: -markerHeight,\n          width: series.clipRect.width + markerWidth * 2,\n          height: series.clipRect.height + markerHeight * 2\n        });\n        markerClipRect = appendClipElement(redraw, options, render);\n      } else {\n        options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));\n        markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');\n      }\n      options = {\n        'id': this.elementId + 'SymbolGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'\n      };\n      series.symbolElement = render.createGroup(options);\n      series.symbolElement.appendChild(markerClipRect);\n      if (this.chart.enableCanvas) {\n        var element = document.getElementById(this.chart.element.id + '_tooltip_svg');\n        element.appendChild(series.symbolElement);\n      }\n    }\n  };\n  Marker.prototype.getRangeLowPoint = function (region, series) {\n    var x = region.x;\n    var y = region.y;\n    if (series.chart.requireInvertedAxis) {\n      y += region.height / 2;\n      x += series.yAxis.isAxisInverse ? region.width : 0;\n    } else {\n      y += series.yAxis.isAxisInverse ? 0 : region.height;\n      x += region.width / 2;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /**\n   * Animates the marker.\n   *\n   * @returns {void}\n   * @private\n   */\n  Marker.prototype.doMarkerAnimation = function (series) {\n    if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose' || series.chart.chartAreaType === 'PolarRadar' && series.drawType === 'Scatter')) {\n      var markerElements = series.symbolElement.childNodes;\n      var delay = series.animation.delay + series.animation.duration;\n      var duration = series.chart.animated ? series.chart.duration : 200;\n      var j = 1;\n      var incFactor = series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea' ? 2 : 1;\n      for (var i = 0; i < series.points.length; i++) {\n        if (series.points[i].symbolLocations) {\n          if (!series.points[i].symbolLocations.length || !markerElements[j]) {\n            continue;\n          }\n          markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);\n          if (incFactor === 2) {\n            var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);\n            markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);\n          }\n          j += incFactor;\n        }\n      }\n    }\n  };\n  return Marker;\n}(MarkerExplode);\nexport { Marker };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","RectOption","appendChildElement","getElement","appendClipElement","findlElement","drawSymbol","markerAnimate","CircleOption","PathOption","Size","isNullOrUndefined","pointRender","MarkerExplode","getSaturationColor","Marker","_super","chart","_this","call","addEventListener","render","series","redraw","createElement","_loop_1","point","visible","symbolLocations","length","map","location","index","marker","shape","renderMarker","_i","_a","points","seriesIndex","undefined","category","border","color","width","borderColor","previousLocation","previousPath","circlePath","shapeOption","x","offset","y","isBoxPlot","type","fill","isFilled","interior","markerElement","parentElement","seriesElement","childNodes","symbolElement","setPointColor","symbolId","elementId","argsData","cancel","name","isEmpty","emptyPointSettings","height","setBorderColor","isRectSeries","trigger","drawType","low","high","outliers","markerFill","markerBorder","markerWidth","markerHeight","markerOpacity","opacity","markerShape","imageURL","imageUrl","enableCanvas","id","getAttribute","toString","renderer","clipRect","setAttribute","duration","markerClipRect","explodeValue","svgRenderer","options","transform","chartAreaType","radius","Math","max","createGroup","appendChild","element","document","getElementById","getRangeLowPoint","region","requireInvertedAxis","yAxis","isAxisInverse","doMarkerAnimation","markerElements","delay","animation","animated","j","incFactor","i","lowPoint","regions"],"sources":["/Users/thonghoangdanh/FullStack/birdnest/node_modules/@syncfusion/ej2-charts/src/chart/series/marker.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { RectOption, appendChildElement, getElement, appendClipElement } from '../../common/utils/helper';\nimport { findlElement, drawSymbol, markerAnimate, CircleOption } from '../../common/utils/helper';\nimport { PathOption, Size } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { pointRender } from '../../common/model/constants';\nimport { MarkerExplode } from './marker-explode';\nimport { getSaturationColor } from '../../common/utils/helper';\n/**\n * Marker module used to render the marker for line type series.\n */\nvar Marker = /** @class */ (function (_super) {\n    __extends(Marker, _super);\n    /**\n     * Constructor for the marker module.\n     *\n     * @private\n     */\n    function Marker(chart) {\n        var _this = _super.call(this, chart) || this;\n        _this.addEventListener();\n        return _this;\n    }\n    /**\n     * Render the marker for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    Marker.prototype.render = function (series) {\n        var _this = this;\n        var redraw = series.chart.redraw;\n        this.createElement(series, redraw);\n        var _loop_1 = function (point) {\n            if (point.visible && point.symbolLocations && point.symbolLocations.length) {\n                point.symbolLocations.map(function (location, index) {\n                    if (series.marker.shape !== 'None') {\n                        _this.renderMarker(series, point, location, index, redraw);\n                    }\n                });\n            }\n        };\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            _loop_1(point);\n        }\n    };\n    Marker.prototype.renderMarker = function (series, point, location, index, redraw) {\n        var seriesIndex = series.index === undefined ? series.category : series.index;\n        var marker = series.marker;\n        var border = {\n            color: marker.border.color,\n            width: marker.border.width\n        };\n        var borderColor = marker.border.color;\n        var previousLocation;\n        var previousPath;\n        var circlePath;\n        var shapeOption;\n        location.x = location.x + marker.offset.x;\n        location.y = location.y - marker.offset.y;\n        var isBoxPlot = series.type === 'BoxAndWhisker';\n        var fill = marker.fill || ((isBoxPlot || series.marker.isFilled) ? point.interior || series.interior : '#ffffff');\n        var markerElement;\n        var parentElement = isBoxPlot ?\n            findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index)\n            : series.symbolElement;\n        border.color = borderColor || series.setPointColor(point, series.interior);\n        var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' +\n            (index ? index : '');\n        var argsData = {\n            cancel: false, name: pointRender, series: series, point: point,\n            fill: point.isEmpty ? (series.emptyPointSettings.fill || fill) : fill,\n            border: {\n                color: series.type === 'BoxAndWhisker' ?\n                    (!isNullOrUndefined(borderColor) && borderColor !== 'transparent') ? borderColor :\n                        getSaturationColor(fill, -0.6)\n                    : border.color,\n                width: border.width\n            },\n            height: marker.height, width: marker.width, shape: marker.shape\n        };\n        argsData.border = series.setBorderColor(point, { width: argsData.border.width, color: argsData.border.color });\n        if (!series.isRectSeries || series.type === 'BoxAndWhisker') {\n            this.chart.trigger(pointRender, argsData);\n            point.color = argsData.fill;\n        }\n        point.color = argsData.fill;\n        if (!argsData.cancel) {\n            var y = void 0;\n            if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn'\n                || series.type === 'SplineRangeArea') {\n                y = index ? point.low : point.high;\n            }\n            else if (isBoxPlot) {\n                y = point.outliers[index];\n            }\n            else {\n                y = point.y;\n            }\n            var markerFill = argsData.point.marker.fill || argsData.fill;\n            var markerBorder = void 0;\n            if (!isNullOrUndefined(argsData.point.marker.border)) {\n                markerBorder = {\n                    color: argsData.point.marker.border.color || argsData.border.color,\n                    width: argsData.point.marker.border.width || argsData.border.width\n                };\n            }\n            else {\n                markerBorder = { color: argsData.border.color, width: argsData.border.width };\n            }\n            var markerWidth = argsData.point.marker.width || argsData.width;\n            var markerHeight = argsData.point.marker.height || argsData.height;\n            var markerOpacity = argsData.point.marker.opacity || marker.opacity;\n            var markerShape = argsData.point.marker.shape || argsData.shape;\n            var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\n            shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, null);\n            if ((parentElement !== undefined && parentElement !== null) || this.chart.enableCanvas) {\n                if (redraw && getElement(shapeOption.id)) {\n                    markerElement = getElement(shapeOption.id);\n                    circlePath = markerShape === 'Circle' ? 'c' : '';\n                    previousLocation = {\n                        x: +markerElement.getAttribute(circlePath + 'x'), y: +markerElement.getAttribute(circlePath + 'y')\n                    };\n                    previousPath = markerElement.getAttribute('d');\n                }\n                markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);\n                if (markerElement) {\n                    markerElement.setAttribute('aria-label', (point.x + \": \" + point.y + ', ' + series.name));\n                }\n                appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);\n            }\n            point.marker = {\n                border: markerBorder, fill: markerFill, height: markerHeight,\n                visible: true, shape: markerShape, width: markerWidth, imageUrl: imageURL\n            };\n        }\n        else {\n            location = null;\n            point.marker = {\n                visible: false\n            };\n        }\n    };\n    Marker.prototype.createElement = function (series, redraw) {\n        var markerClipRect;\n        var marker = series.marker;\n        // 8 for extend border value 5 for extend size value\n        var explodeValue = marker.border.width + 8 + 5;\n        var render = series.chart.svgRenderer;\n        var index = series.index === undefined ? series.category : series.index;\n        var options;\n        var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')' : '';\n        if (marker.visible) {\n            var markerHeight = (marker.height + explodeValue) / 2;\n            var markerWidth = (marker.width + explodeValue) / 2;\n            if (series.chart.chartAreaType === 'Cartesian') {\n                options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                    x: -markerWidth, y: -markerHeight,\n                    width: series.clipRect.width + markerWidth * 2,\n                    height: series.clipRect.height + markerHeight * 2\n                });\n                markerClipRect = appendClipElement(redraw, options, render);\n            }\n            else {\n                options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));\n                markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');\n            }\n            options = {\n                'id': this.elementId + 'SymbolGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'\n            };\n            series.symbolElement = render.createGroup(options);\n            series.symbolElement.appendChild(markerClipRect);\n            if (this.chart.enableCanvas) {\n                var element = document.getElementById(this.chart.element.id + '_tooltip_svg');\n                element.appendChild(series.symbolElement);\n            }\n        }\n    };\n    Marker.prototype.getRangeLowPoint = function (region, series) {\n        var x = region.x;\n        var y = region.y;\n        if (series.chart.requireInvertedAxis) {\n            y += region.height / 2;\n            x += series.yAxis.isAxisInverse ? region.width : 0;\n        }\n        else {\n            y += series.yAxis.isAxisInverse ? 0 : region.height;\n            x += region.width / 2;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Animates the marker.\n     *\n     * @returns {void}\n     * @private\n     */\n    Marker.prototype.doMarkerAnimation = function (series) {\n        if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' ||\n            series.type === 'HiloOpenClose' || (series.chart.chartAreaType === 'PolarRadar' && (series.drawType === 'Scatter')))) {\n            var markerElements = series.symbolElement.childNodes;\n            var delay = series.animation.delay + series.animation.duration;\n            var duration = series.chart.animated ? series.chart.duration : 200;\n            var j = 1;\n            var incFactor = (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea') ? 2 : 1;\n            for (var i = 0; i < series.points.length; i++) {\n                if (series.points[i].symbolLocations) {\n                    if (!series.points[i].symbolLocations.length || !markerElements[j]) {\n                        continue;\n                    }\n                    markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);\n                    if (incFactor === 2) {\n                        var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);\n                        markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);\n                    }\n                    j += incFactor;\n                }\n            }\n        }\n    };\n    return Marker;\n}(MarkerExplode));\nexport { Marker };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}